<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>ventiliser.PhaseLabeller API documentation</title>
<meta name="description" content="Created on Tue Apr 21 23:41:13 2020 â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ventiliser.PhaseLabeller</code></h1>
</header>
<section id="section-intro">
<p>Created on Tue Apr 21 23:41:13 2020</p>
<p>@author: David Chong Tian Wei</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Tue Apr 21 23:41:13 2020

@author: David Chong Tian Wei
&#34;&#34;&#34;
import math
import numpy as np
import pandas as pd
from atpbar import atpbar
from ventiliser.FlowStates import FlowStates as fs
from ventiliser.PressureStates import PressureStates as ps
from ventiliser.BreathVariables import BreathVariables

class PhaseLabeller:
    &#34;&#34;&#34; Class for segmenting and labelling breath sub-phases
    
    Attributes
    ----------
    breaths : array like of BreathVariables
        Array containing the BreathVariables after calling process
    freq : real
        Sampling rate for the record to be processed
    max_hold : integer
        Threshold in number of data points for the amount of time a breath can be in a no flow state before considered termintated
    leak_perc_thresh : real
        The proportion of leak permitted before breath is conidered physiologically implausible and to be flagged for merging in post processing
    exp_hold_len : integer
        The time in number of data points of the expiratory hold that must occur between breaths to deflag for merging in post-processing
    permit_double_cycling : boolean
        Decide whether to merge double cycles in post-processing
    
    &#34;&#34;&#34;
    def __init__(self):
        self.configure()
    
    def configure(self, freq=100, hold_length=0.5, leak_perc_thresh=0.66, exp_hold_len=0.05, permit_double_cycling = False):
        &#34;&#34;&#34; 
        Sets the constants for segmentation and post-processing
        
        Parameters
        ----------
        freq : int, optional
            Sampling rate of the input data. Defaults to 100
        hold_length : real, optional
            Threshold in seconds for the amount of time a breath can be in a no flow state before considered termintated. Defaults to 0.5s
        leak_perc_thresh : real, optional
            The proportion of leak permitted before breath is conidered physiologically implausible and to be flagged for merging in post processing. Defaults to 66%
        exp_hold_len : real, optional
            The time in seconds of the expiratory hold that must occur between breaths to deflag for merging in post-processing. Defaults to 0.05s
        permit_double_cycling : boolean, optional
            Decide whether to merge double cycles in post-processing based on exp_hold_len. Defaults to false.
            
        Returns
        -------
        None
        &#34;&#34;&#34;
        self.breaths = []
        self.freq = freq
        self.max_hold = math.ceil(freq * hold_length)
        self.leak_perc_thresh = leak_perc_thresh
        self.exp_hold_len = math.ceil(freq * exp_hold_len)
        self.permit_double_cycling = permit_double_cycling
    
    def process(self, p_labels, f_labels, pressures, flows, post_processing=True):
        &#34;&#34;&#34;
        Given the pressure and flow data points and labels, segments the data into breaths, identifies respiratory sub-phases, and calculates some physiological values
        
        Parameters
        ----------
        p_labels : array like of PressureStates enum
            The PressureStates labels generated from StateMapper
        f_labels : array like of FlowStates enum
            The FlowStates labels generated from StateMapper
        pressures : array like of real
            Pressure data points
        flows : array like of real
            Flow data points
        post_processing : boolean, optional
            Flag for deciding whether to run post processing or not. Defaults to True
            
        Returns
        -------
        None
        &#34;&#34;&#34;
        if type(pressures) is not np.array:
            pressures = np.array(pressures)
        if type(flows) is not np.array:
            flows = np.array(flows)
        print(&#34;Segmenting into breaths&#34;)
        self.breaths += [BreathVariables()]
        self.breaths[-1].breath_end = 0
        while(self.breaths[-1].breath_end != len(f_labels)):
            self.breaths += [self.__get_next_breath(f_labels, self.breaths[-1].breath_end)]
        # First and last breaths are usually inaccurate
        if len(self.breaths) &gt; 1:
            self.breaths = self.breaths[1:]
            print(str(len(self.breaths)) + &#34; breaths identified&#34;)
            for i in atpbar(range(len(self.breaths)), name=&#34;Processing breaths&#34;):
                self.breaths[i].breath_number = i+1
                self.__information_approach(p_labels, f_labels, self.breaths[i])
                self.__calculate_features(self.breaths[i], pressures, flows)
            if post_processing:
                self.__post_process(p_labels, f_labels, pressures, flows)
        else:
            self.breaths = []
            print(&#34;Warning: No breaths identified&#34;)
    
    def get_breaths(self, length_units=&#34;ms&#34;):
        &#34;&#34;&#34;
        Returns the segmented breaths and calculated features as a pandas dataframe. See BreathVariables for list of variables returned
        
        Parameters
        ----------
        length_units : string, optional
            Unit to use for length calculations, accepts &#39;ms&#39; and &#39;s&#39; for milliseconds and seconds respectively. Defaults to ms
        
        Returns
        --------
        Pandas Dataframe
            Table of segmented breaths and charactersitics for each breath with lengths scaled according to given unit
        &#34;&#34;&#34;
        df = pd.DataFrame([vars(x) for x in self.breaths])
        if length_units == &#34;ms&#34;:
            df[list(filter(lambda x : &#34;length&#34; in x, df.columns))] *= 1000 / self.freq
        elif length_units == &#34;s&#34;:
            df[list(filter(lambda x : &#34;length&#34; in x, df.columns))] *= 1 / self.freq
        return df[[&#34;breath_number&#34;, &#34;breath_start&#34;, &#34;breath_end&#34;, &#34;inspiration_initiation_start&#34;, &#34;peak_inspiratory_flow_start&#34;,
                  &#34;inspiration_termination_start&#34;, &#34;inspiratory_hold_start&#34;, &#34;expiration_initiation_start&#34;,     &#34;peak_expiratory_flow_start&#34;,
                  &#34;expiration_termination_start&#34;, &#34;expiratory_hold_start&#34;, &#34;pressure_rise_start&#34;, &#34;pip_start&#34;, &#34;pressure_drop_start&#34;,
                  &#34;peep_start&#34;, &#34;inspiration_initiation_length&#34;, &#34;peak_inspiratory_flow_length&#34;,
                  &#34;inspiration_termination_length&#34;, &#34;inspiratory_hold_length&#34;, &#34;expiration_initiation_length&#34;, &#34;peak_expiratory_flow_length&#34;,
                  &#34;expiration_termination_length&#34;, &#34;expiratory_hold_length&#34;, &#34;pressure_rise_length&#34;, &#34;pip_length&#34;, &#34;pressure_drop_length&#34;,
                  &#34;peep_length&#34;, &#34;pip_to_no_flow_length&#34;, &#34;peep_to_no_flow_length&#34;, &#34;lung_inflation_length&#34;, &#34;total_inspiratory_length&#34;,
                  &#34;lung_deflation_length&#34;, &#34;total_expiratory_length&#34;, &#34;inspiratory_volume&#34;, &#34;expiratory_volume&#34;, &#34;max_inspiratory_flow&#34;,
                  &#34;max_expiratory_flow&#34;, &#34;max_pressure&#34;, &#34;min_pressure&#34;, &#34;pressure_flow_correlation&#34;]]
        
    def get_breaths_raw(self):
        &#34;&#34;&#34;
        Returns the segmented breaths and calculated features as a pandas dataframe. See BreathVariables for list of variables returned
        
        Returns
        --------
        Pandas Dataframe
            Table of segmented breaths and charactersitics for each breath
        &#34;&#34;&#34;
        return pd.DataFrame([vars(x) for x in self.breaths])
    
    def get_breath_annotations(self, N, p_states=list(ps), f_states=list(fs)):
        &#34;&#34;&#34; 
        Returns a Nx3 dataframe containing key points of breaths mapped to indices to be used with GUI annotator for viewing
        
        Parameters
        ----------
        N : int
            Length of the sample that was analyzed (in terms of data points)
        p_states : array like of PressureStates, optional
            The pressure states from each breath that you would like mapped. Defaults to all enums in PressureStates.
        f_states : array like of FlowStates, optional
            The flow states from each breath that you woudld like mapped. Defaults to all enums in FlowStates
        
        Returns
        -------
        Pandas Dataframe
            Dataframe containing keypoints at each index of the data on which the analysis was performed
        &#34;&#34;&#34;
        output = np.full((N,3), -1)
        output[:,0] = np.arange(N)
        breaths = self.get_breaths_raw()
        for p in p_states:
            if p == ps.pressure_rise:
                output[breaths[&#34;pressure_rise_start&#34;]-1,1] = ps.pressure_rise.value
            elif p == ps.pip:
                output[breaths[&#34;pip_start&#34;]-1,1] = ps.pip.value
            elif p == ps.pressure_drop:
                output[breaths[&#34;pressure_drop_start&#34;]-1,1] = ps.pressure_drop.value
            elif p == ps.peep:
                output[breaths[&#34;peep_start&#34;]-1,1] = ps.peep.value
        for f in f_states:
            if f == fs.inspiration_initiation:
                output[breaths[&#34;inspiration_initiation_start&#34;]-1,2] = fs.inspiration_initiation.value
            elif f == fs.peak_inspiratory_flow:
                output[breaths[&#34;peak_inspiratory_flow_start&#34;]-1,2] = fs.peak_inspiratory_flow.value
            elif f == fs.inspiration_termination:
                output[breaths[&#34;inspiration_termination_start&#34;]-1,2] = fs.inspiration_termination.value
            elif f == fs.no_flow:
                output[breaths[&#34;inspiratory_hold_start&#34;]-1,2] = fs.no_flow.value
                output[breaths[&#34;expiratory_hold_start&#34;]-1,2] = fs.no_flow.value
            elif f == fs.expiration_initiation:
                output[breaths[&#34;expiration_initiation_start&#34;]-1,2] = fs.expiration_initiation.value
            elif f == fs.peak_expiratory_flow:
                output[breaths[&#34;peak_expiratory_flow_start&#34;]-1,2] = fs.peak_expiratory_flow.value
            elif f == fs.expiration_termination:
                output[breaths[&#34;expiration_termination_start&#34;]-1,2] = fs.expiration_termination.value
        output = output[output[:,1:].sum(axis=1) != -2,:]
        output = pd.DataFrame(output)
        output.columns = [&#34;index&#34;,&#34;pressure_annotations&#34;,&#34;flow_annotations&#34;]
        return output
    
    def __get_next_breath(self, labels, start):
        &#34;&#34;&#34;
        Identifies the next breath in the record based on Inspiration-Inspiration interval
        
        Parameters
        ----------
        labels : array like of FlowStates enum
            The array of flow labels calculated from a StateMapper object
        start : integer
            Index from which to start searching for a breath
        
        Returns
        -------
        BreathVariables object
            A breath object containing the start and end points
        &#34;&#34;&#34;
        running_hold = 0
        expiration_encountered = False
        for i in range(start, len(labels)):
            if labels[i] is fs.inspiration_initiation or labels[i] is fs.peak_inspiratory_flow:
                running_hold = 0
                # If this is the start of the recording, the start index may be inaccurate so we reset it here
                if start == 0:
                    start = i
                    expiration_encountered=False
                if expiration_encountered:
                    breath = BreathVariables()
                    breath.breath_start = start
                    breath.breath_end = i
                    return breath
            elif labels[i] is fs.expiration_initiation or labels[i] is fs.peak_expiratory_flow or labels[i] is fs.expiration_termination or running_hold &gt; self.max_hold:
                expiration_encountered = True
            elif labels[i] is fs.no_flow:
                running_hold += 1
                
        # If code reaches this point then it is the last breath of the record
        breath = BreathVariables()
        breath.breath_start = start
        breath.breath_end = len(labels)
        return breath
    
    def __maximise_information_gain(self, labels, target_classes):
        &#34;&#34;&#34;
        Finds the split on the given labels which maximises information gain
        
        Parameters
        ----------
        labels : array like of PressureStates or FlowStates
            An array of labels (enumerated flow/pressure states)
        target_classes : array like of PressureStates or FlowStates
            An array of labels (enumerated flow/pressure states) to use to calculate information gain
        
        Returns
        -------
        (int, array like of PressureStates or FlowStates, array like of PressureStates or FlowStates)
            Returns the index of the split, the states up to index, states from index to the end
        &#34;&#34;&#34;
        some_exists = False
        for target_class in target_classes:
            if target_class in labels:
                some_exists = True
                break
        if not some_exists:
            return (0, np.array([]), labels)
        if len(labels) == 0:
            return (0, np.array([]), labels)
        elif len(labels) == 1:
            for target_class in target_classes:
                if target_class in labels:
                    return(1, labels, np.array([]))
            return (0, np.array([]), labels)
        # Find p
        xlen = len(labels)
        forward = np.arange(1,xlen)
        backward = np.arange(xlen-1,0,step=-1)
        p = 0
        p2 = 0
        for target_class in target_classes:
            p += (labels == target_class).cumsum()[:-1]
        p2 = (p[-1] - np.copy(p)) / backward
        p = p / forward
        inf = ((-p * np.log(p + 1E-7)) * forward + (-p2 * np.log(p2 + 1E-7)) * backward) / xlen
        p_prime = 1-p
        p2_prime = 1-p2
        inf += ((-p_prime * np.log(p_prime + 1E-7 )) * forward + (-p2_prime * np.log(p2_prime + 1E-7)) * backward) / xlen
        idx = np.argmin(inf) + 1
        return (idx, labels[:idx], labels[idx:])
       
    def __information_approach(self, p_labels, f_labels, breath):
        &#34;&#34;&#34;
        Tries to identify sub-phases of each breath based on maximising information gain on splitting
        
        Parameters
        ----------
        p_labels : array like of PressureStates enum
            Pressure labels for the record calculated using StateMapper
        f_labels : array like of FlowStates enum
            Flow labels for the record calculated using StateMapper
        breath : BreathVariables object
            BreathVariables object for the breath to calculate sub phases
        
        Returns
        -------
        None
        &#34;&#34;&#34;
        p_labels = p_labels[breath.breath_start:breath.breath_end]
        f_labels = f_labels[breath.breath_start:breath.breath_end]
        labels = f_labels
        # Inspiration initiation at breath start by segmentation definition
        breath.inspiration_initiation_start = breath.breath_start
        # Find Peak inspiratory flow start by finding end of split
        breath.peak_inspiratory_flow_start, _, labels = self.__maximise_information_gain(labels, [fs.inspiration_initiation])
        breath.peak_inspiratory_flow_start += breath.breath_start
        # Find Inspiration termination start by finding end of split
        breath.inspiration_termination_start, _, labels = self.__maximise_information_gain(labels, [fs.peak_inspiratory_flow])
        breath.inspiration_termination_start += breath.peak_inspiratory_flow_start
        # Find Inspiratory Hold start by finding end of split
        breath.inspiratory_hold_start, _, labels = self.__maximise_information_gain(labels, [fs.inspiration_termination])
        breath.inspiratory_hold_start += breath.inspiration_termination_start
        # Find Peak expiratory flow start by finding end of split
        breath.peak_expiratory_flow_start, _, labels = self.__maximise_information_gain(labels, [fs.expiration_initiation])
        breath.peak_expiratory_flow_start += breath.inspiratory_hold_start
        # Find Expiratory hold start by finding end of split
        no_flow, _, labels = self.__maximise_information_gain(labels, [fs.no_flow])
        if no_flow == 0:
            breath.expiratory_hold_start = breath.breath_end
        else:
            breath.expiratory_hold_start = breath.peak_expiratory_flow_start + no_flow        
        # Find Expiration Termination Start by finding end of split
        templabels = f_labels[breath.peak_expiratory_flow_start - breath.breath_start : breath.expiratory_hold_start - breath.breath_start]
        breath.expiration_termination_start, _, labels = self.__maximise_information_gain(templabels, [fs.peak_expiratory_flow])
        breath.expiration_termination_start += breath.peak_expiratory_flow_start
        # Find expiration initiation start by finding end of split
        templabels = f_labels[breath.inspiratory_hold_start - breath.breath_start : breath.peak_expiratory_flow_start - breath.breath_start]
        breath.expiration_initiation_start, _, labels = self.__maximise_information_gain(templabels, [fs.no_flow])
        breath.expiration_initiation_start += breath.inspiratory_hold_start
        
        labels = p_labels
        # Find pip start by finding end of split
        breath.pip_start, _, labels = self.__maximise_information_gain(labels, [ps.pressure_rise])
        breath.pip_start += breath.breath_start
        
        # Find pressure drop start by finding end of split
        breath.pressure_drop_start, _, labels = self.__maximise_information_gain(labels, [ps.pip])
        breath.pressure_drop_start += breath.pip_start
        
        # Find peep start by finding start of split
        breath.peep_start, _, labels = self.__maximise_information_gain(labels, [ps.pressure_drop])
        breath.peep_start += breath.pressure_drop_start
        
        # Find pressure rise start by finding start of split
        breath.pressure_rise_start, _, labels = self.__maximise_information_gain(p_labels[:breath.pip_start - breath.breath_start], [ps.peep])
        breath.pressure_rise_start += breath.breath_start
    
    def __calculate_features(self, breath, pressures, flows):
        &#34;&#34;&#34;
        Calculates the values relevant for physiology like tidal volumes and respiratory phase lengths
        
        Parameters
        ----------
        breath : BreathVariables object
            The breath for which to calculate the physiological values
        pressures : array like of real
            Pressure data points
        flows : array like of real
            Flow data points
        
        Returns
        -------
        None
        &#34;&#34;&#34;
        p = np.array(pressures[breath.breath_start:breath.breath_end])
        f = np.array(flows[breath.breath_start:breath.breath_end])

        # Pressure phases
        breath.pressure_rise_length = breath.pip_start - breath.pressure_rise_start
        breath.pip_length = breath.pressure_drop_start - breath.pip_start
        breath.pressure_drop_length = breath.peep_start - breath.pressure_drop_start
        breath.peep_length = breath.breath_end - breath.peep_start
        
        # Flow phases
        breath.inspiration_initiation_length = breath.peak_inspiratory_flow_start - breath.inspiration_initiation_start
        breath.peak_inspiratory_flow_length = breath.inspiration_termination_start - breath.peak_inspiratory_flow_start
        breath.inspiration_termination_length = breath.inspiratory_hold_start - breath.inspiration_termination_start
        breath.inspiratory_hold_length = breath.expiration_initiation_start - breath.inspiratory_hold_start
        breath.expiration_initiation_length = breath.peak_expiratory_flow_start - breath.expiration_initiation_start
        breath.peak_expiratory_flow_length = breath.expiration_termination_start - breath.peak_expiratory_flow_start
        breath.expiration_termination_length = breath.expiratory_hold_start - breath.expiration_termination_start
        breath.expiratory_hold_length = breath.breath_end - breath.expiratory_hold_start
        breath.lung_inflation_length = breath.inspiratory_hold_start - breath.inspiration_initiation_start
        breath.total_inspiratory_length = breath.expiration_initiation_start - breath.inspiration_initiation_start
        breath.lung_deflation_length = breath.expiratory_hold_start - breath.expiration_initiation_start
        breath.total_expiratory_length = breath.breath_end - breath.expiration_initiation_start
        breath.pip_to_no_flow_length = breath.inspiratory_hold_start - breath.pip_start
        breath.peep_to_no_flow_length = breath.expiratory_hold_start - breath.peep_start
        
        # Volumes
        breath.inspiratory_volume = f[f &gt; 0].sum()
        breath.expiratory_volume = np.abs(f[f &lt; 0].sum())
        breath.max_inspiratory_flow = f.max()
        breath.max_expiratory_flow = f.min()
        
        # Pressures
        breath.max_pressure = p.max()
        breath.min_pressure = p.min()
        
        # Correlation
        breath.pressure_flow_correlation = np.corrcoef(p,f)[0,1]
    
    def __post_process(self, p_labels, f_labels, pressures, flows):
        &#34;&#34;&#34; 
        Performs merging of adjacent breaths dependent on whether inspiration and expiration volumes match
        
        Parameters
        ----------
        p_labels : array like of PressureStates enum
            Pressure labels for the record calculated using StateMapper
        f_labels : array like of FlowStates enum
            Flow labels for the record calculated using StateMapper
        pressures : array like of real
            Pressure data points
        flows : array like of real
            Flow data points
       
        Returns
        -------
        None
        &#34;&#34;&#34;
        merged_breaths = [self.breaths[0]]
        begin_merge = False
        insp_sum = 0
        exp_sum = 0
        error_start = 0
        for i in atpbar(range(1,len(self.breaths)), name=&#34;Post-processing&#34;):
            if not begin_merge:
                breath_leak_perc = (self.breaths[i].inspiratory_volume - self.breaths[i].expiratory_volume) / self.breaths[i].inspiratory_volume
                if abs(breath_leak_perc) &gt; self.leak_perc_thresh:
                    if breath_leak_perc &lt; 0 and self.breaths[i-1].expiratory_hold_length &lt;= self.exp_hold_len:
                        error_start = i - 1
                        merged_breaths.pop()
                        begin_merge = True
                        insp_sum += self.breaths[i-1].inspiratory_volume + self.breaths[i].inspiratory_volume
                        exp_sum += self.breaths[i-1].expiratory_volume + self.breaths[i].expiratory_volume
                    elif breath_leak_perc &gt; 0 and self.breaths[i-1].expiratory_hold_length &lt;= self.exp_hold_len:
                        begin_merge = True
                        error_start = i
                        insp_sum += self.breaths[i].inspiratory_volume
                        exp_sum += self.breaths[i].expiratory_volume
                    else:
                        merged_breaths += [self.breaths[i]]
                else:
                    merged_breaths += [self.breaths[i]]
            else:
                if ((abs(insp_sum - exp_sum)/insp_sum &lt; self.leak_perc_thresh or self.breaths[i-1].expiratory_hold_length &gt; self.exp_hold_len) and error_start != i-1) or (self.breaths[i].pressure_flow_correlation &gt; 0.2 and not self.permit_double_cycling):
                    # Begin to merge breaths
                    begin_merge = False
                    insp_sum = 0
                    exp_sum = 0
                    merged_breath = BreathVariables()
                    merged_breath.breath_start = self.breaths[error_start].breath_start
                    merged_breath.breath_end = self.breaths[i-1].breath_end
                    self.__information_approach(p_labels, f_labels, merged_breath)
                    self.__calculate_features(merged_breath, pressures, flows)
                    merged_breaths += [merged_breath]
                    # Check if current breath needs to be merged
                    breath_leak_perc = (self.breaths[i].inspiratory_volume - self.breaths[i].expiratory_volume) / self.breaths[i].inspiratory_volume
                    if abs(breath_leak_perc) &gt; self.leak_perc_thresh:
                        if breath_leak_perc &lt; 0 and self.breaths[i].expiratory_hold_length &lt;= self.exp_hold_len:
                            merged_breaths.pop()
                            begin_merge = True
                            insp_sum += self.breaths[i-1].inspiratory_volume + self.breaths[i].inspiratory_volume
                            exp_sum += self.breaths[i-1].expiratory_volume + self.breaths[i].expiratory_volume
                        elif breath_leak_perc &gt; 0 and self.breaths[i].expiratory_hold_length &lt;= self.exp_hold_len:
                            begin_merge = True
                            error_start = i
                            insp_sum += self.breaths[i].inspiratory_volume
                            exp_sum += self.breaths[i].expiratory_volume
                        else:
                            merged_breaths += [self.breaths[i]]
                    else:
                        merged_breaths += [self.breaths[i]]
                else:
                    insp_sum += self.breaths[i].inspiratory_volume
                    exp_sum += self.breaths[i].expiratory_volume
        
        self.breaths = merged_breaths
        for i in atpbar(range(len(self.breaths)), name=&#34;Re-numbering breaths&#34;):
            self.breaths[i].breath_number = i+1</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ventiliser.PhaseLabeller.PhaseLabeller"><code class="flex name class">
<span>class <span class="ident">PhaseLabeller</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class for segmenting and labelling breath sub-phases</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>breaths</code></strong> :&ensp;<code>array like</code> of <code>BreathVariables</code></dt>
<dd>Array containing the BreathVariables after calling process</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>real</code></dt>
<dd>Sampling rate for the record to be processed</dd>
<dt><strong><code>max_hold</code></strong> :&ensp;<code>integer</code></dt>
<dd>Threshold in number of data points for the amount of time a breath can be in a no flow state before considered termintated</dd>
<dt><strong><code>leak_perc_thresh</code></strong> :&ensp;<code>real</code></dt>
<dd>The proportion of leak permitted before breath is conidered physiologically implausible and to be flagged for merging in post processing</dd>
<dt><strong><code>exp_hold_len</code></strong> :&ensp;<code>integer</code></dt>
<dd>The time in number of data points of the expiratory hold that must occur between breaths to deflag for merging in post-processing</dd>
<dt><strong><code>permit_double_cycling</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Decide whether to merge double cycles in post-processing</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PhaseLabeller:
    &#34;&#34;&#34; Class for segmenting and labelling breath sub-phases
    
    Attributes
    ----------
    breaths : array like of BreathVariables
        Array containing the BreathVariables after calling process
    freq : real
        Sampling rate for the record to be processed
    max_hold : integer
        Threshold in number of data points for the amount of time a breath can be in a no flow state before considered termintated
    leak_perc_thresh : real
        The proportion of leak permitted before breath is conidered physiologically implausible and to be flagged for merging in post processing
    exp_hold_len : integer
        The time in number of data points of the expiratory hold that must occur between breaths to deflag for merging in post-processing
    permit_double_cycling : boolean
        Decide whether to merge double cycles in post-processing
    
    &#34;&#34;&#34;
    def __init__(self):
        self.configure()
    
    def configure(self, freq=100, hold_length=0.5, leak_perc_thresh=0.66, exp_hold_len=0.05, permit_double_cycling = False):
        &#34;&#34;&#34; 
        Sets the constants for segmentation and post-processing
        
        Parameters
        ----------
        freq : int, optional
            Sampling rate of the input data. Defaults to 100
        hold_length : real, optional
            Threshold in seconds for the amount of time a breath can be in a no flow state before considered termintated. Defaults to 0.5s
        leak_perc_thresh : real, optional
            The proportion of leak permitted before breath is conidered physiologically implausible and to be flagged for merging in post processing. Defaults to 66%
        exp_hold_len : real, optional
            The time in seconds of the expiratory hold that must occur between breaths to deflag for merging in post-processing. Defaults to 0.05s
        permit_double_cycling : boolean, optional
            Decide whether to merge double cycles in post-processing based on exp_hold_len. Defaults to false.
            
        Returns
        -------
        None
        &#34;&#34;&#34;
        self.breaths = []
        self.freq = freq
        self.max_hold = math.ceil(freq * hold_length)
        self.leak_perc_thresh = leak_perc_thresh
        self.exp_hold_len = math.ceil(freq * exp_hold_len)
        self.permit_double_cycling = permit_double_cycling
    
    def process(self, p_labels, f_labels, pressures, flows, post_processing=True):
        &#34;&#34;&#34;
        Given the pressure and flow data points and labels, segments the data into breaths, identifies respiratory sub-phases, and calculates some physiological values
        
        Parameters
        ----------
        p_labels : array like of PressureStates enum
            The PressureStates labels generated from StateMapper
        f_labels : array like of FlowStates enum
            The FlowStates labels generated from StateMapper
        pressures : array like of real
            Pressure data points
        flows : array like of real
            Flow data points
        post_processing : boolean, optional
            Flag for deciding whether to run post processing or not. Defaults to True
            
        Returns
        -------
        None
        &#34;&#34;&#34;
        if type(pressures) is not np.array:
            pressures = np.array(pressures)
        if type(flows) is not np.array:
            flows = np.array(flows)
        print(&#34;Segmenting into breaths&#34;)
        self.breaths += [BreathVariables()]
        self.breaths[-1].breath_end = 0
        while(self.breaths[-1].breath_end != len(f_labels)):
            self.breaths += [self.__get_next_breath(f_labels, self.breaths[-1].breath_end)]
        # First and last breaths are usually inaccurate
        if len(self.breaths) &gt; 1:
            self.breaths = self.breaths[1:]
            print(str(len(self.breaths)) + &#34; breaths identified&#34;)
            for i in atpbar(range(len(self.breaths)), name=&#34;Processing breaths&#34;):
                self.breaths[i].breath_number = i+1
                self.__information_approach(p_labels, f_labels, self.breaths[i])
                self.__calculate_features(self.breaths[i], pressures, flows)
            if post_processing:
                self.__post_process(p_labels, f_labels, pressures, flows)
        else:
            self.breaths = []
            print(&#34;Warning: No breaths identified&#34;)
    
    def get_breaths(self, length_units=&#34;ms&#34;):
        &#34;&#34;&#34;
        Returns the segmented breaths and calculated features as a pandas dataframe. See BreathVariables for list of variables returned
        
        Parameters
        ----------
        length_units : string, optional
            Unit to use for length calculations, accepts &#39;ms&#39; and &#39;s&#39; for milliseconds and seconds respectively. Defaults to ms
        
        Returns
        --------
        Pandas Dataframe
            Table of segmented breaths and charactersitics for each breath with lengths scaled according to given unit
        &#34;&#34;&#34;
        df = pd.DataFrame([vars(x) for x in self.breaths])
        if length_units == &#34;ms&#34;:
            df[list(filter(lambda x : &#34;length&#34; in x, df.columns))] *= 1000 / self.freq
        elif length_units == &#34;s&#34;:
            df[list(filter(lambda x : &#34;length&#34; in x, df.columns))] *= 1 / self.freq
        return df[[&#34;breath_number&#34;, &#34;breath_start&#34;, &#34;breath_end&#34;, &#34;inspiration_initiation_start&#34;, &#34;peak_inspiratory_flow_start&#34;,
                  &#34;inspiration_termination_start&#34;, &#34;inspiratory_hold_start&#34;, &#34;expiration_initiation_start&#34;,     &#34;peak_expiratory_flow_start&#34;,
                  &#34;expiration_termination_start&#34;, &#34;expiratory_hold_start&#34;, &#34;pressure_rise_start&#34;, &#34;pip_start&#34;, &#34;pressure_drop_start&#34;,
                  &#34;peep_start&#34;, &#34;inspiration_initiation_length&#34;, &#34;peak_inspiratory_flow_length&#34;,
                  &#34;inspiration_termination_length&#34;, &#34;inspiratory_hold_length&#34;, &#34;expiration_initiation_length&#34;, &#34;peak_expiratory_flow_length&#34;,
                  &#34;expiration_termination_length&#34;, &#34;expiratory_hold_length&#34;, &#34;pressure_rise_length&#34;, &#34;pip_length&#34;, &#34;pressure_drop_length&#34;,
                  &#34;peep_length&#34;, &#34;pip_to_no_flow_length&#34;, &#34;peep_to_no_flow_length&#34;, &#34;lung_inflation_length&#34;, &#34;total_inspiratory_length&#34;,
                  &#34;lung_deflation_length&#34;, &#34;total_expiratory_length&#34;, &#34;inspiratory_volume&#34;, &#34;expiratory_volume&#34;, &#34;max_inspiratory_flow&#34;,
                  &#34;max_expiratory_flow&#34;, &#34;max_pressure&#34;, &#34;min_pressure&#34;, &#34;pressure_flow_correlation&#34;]]
        
    def get_breaths_raw(self):
        &#34;&#34;&#34;
        Returns the segmented breaths and calculated features as a pandas dataframe. See BreathVariables for list of variables returned
        
        Returns
        --------
        Pandas Dataframe
            Table of segmented breaths and charactersitics for each breath
        &#34;&#34;&#34;
        return pd.DataFrame([vars(x) for x in self.breaths])
    
    def get_breath_annotations(self, N, p_states=list(ps), f_states=list(fs)):
        &#34;&#34;&#34; 
        Returns a Nx3 dataframe containing key points of breaths mapped to indices to be used with GUI annotator for viewing
        
        Parameters
        ----------
        N : int
            Length of the sample that was analyzed (in terms of data points)
        p_states : array like of PressureStates, optional
            The pressure states from each breath that you would like mapped. Defaults to all enums in PressureStates.
        f_states : array like of FlowStates, optional
            The flow states from each breath that you woudld like mapped. Defaults to all enums in FlowStates
        
        Returns
        -------
        Pandas Dataframe
            Dataframe containing keypoints at each index of the data on which the analysis was performed
        &#34;&#34;&#34;
        output = np.full((N,3), -1)
        output[:,0] = np.arange(N)
        breaths = self.get_breaths_raw()
        for p in p_states:
            if p == ps.pressure_rise:
                output[breaths[&#34;pressure_rise_start&#34;]-1,1] = ps.pressure_rise.value
            elif p == ps.pip:
                output[breaths[&#34;pip_start&#34;]-1,1] = ps.pip.value
            elif p == ps.pressure_drop:
                output[breaths[&#34;pressure_drop_start&#34;]-1,1] = ps.pressure_drop.value
            elif p == ps.peep:
                output[breaths[&#34;peep_start&#34;]-1,1] = ps.peep.value
        for f in f_states:
            if f == fs.inspiration_initiation:
                output[breaths[&#34;inspiration_initiation_start&#34;]-1,2] = fs.inspiration_initiation.value
            elif f == fs.peak_inspiratory_flow:
                output[breaths[&#34;peak_inspiratory_flow_start&#34;]-1,2] = fs.peak_inspiratory_flow.value
            elif f == fs.inspiration_termination:
                output[breaths[&#34;inspiration_termination_start&#34;]-1,2] = fs.inspiration_termination.value
            elif f == fs.no_flow:
                output[breaths[&#34;inspiratory_hold_start&#34;]-1,2] = fs.no_flow.value
                output[breaths[&#34;expiratory_hold_start&#34;]-1,2] = fs.no_flow.value
            elif f == fs.expiration_initiation:
                output[breaths[&#34;expiration_initiation_start&#34;]-1,2] = fs.expiration_initiation.value
            elif f == fs.peak_expiratory_flow:
                output[breaths[&#34;peak_expiratory_flow_start&#34;]-1,2] = fs.peak_expiratory_flow.value
            elif f == fs.expiration_termination:
                output[breaths[&#34;expiration_termination_start&#34;]-1,2] = fs.expiration_termination.value
        output = output[output[:,1:].sum(axis=1) != -2,:]
        output = pd.DataFrame(output)
        output.columns = [&#34;index&#34;,&#34;pressure_annotations&#34;,&#34;flow_annotations&#34;]
        return output
    
    def __get_next_breath(self, labels, start):
        &#34;&#34;&#34;
        Identifies the next breath in the record based on Inspiration-Inspiration interval
        
        Parameters
        ----------
        labels : array like of FlowStates enum
            The array of flow labels calculated from a StateMapper object
        start : integer
            Index from which to start searching for a breath
        
        Returns
        -------
        BreathVariables object
            A breath object containing the start and end points
        &#34;&#34;&#34;
        running_hold = 0
        expiration_encountered = False
        for i in range(start, len(labels)):
            if labels[i] is fs.inspiration_initiation or labels[i] is fs.peak_inspiratory_flow:
                running_hold = 0
                # If this is the start of the recording, the start index may be inaccurate so we reset it here
                if start == 0:
                    start = i
                    expiration_encountered=False
                if expiration_encountered:
                    breath = BreathVariables()
                    breath.breath_start = start
                    breath.breath_end = i
                    return breath
            elif labels[i] is fs.expiration_initiation or labels[i] is fs.peak_expiratory_flow or labels[i] is fs.expiration_termination or running_hold &gt; self.max_hold:
                expiration_encountered = True
            elif labels[i] is fs.no_flow:
                running_hold += 1
                
        # If code reaches this point then it is the last breath of the record
        breath = BreathVariables()
        breath.breath_start = start
        breath.breath_end = len(labels)
        return breath
    
    def __maximise_information_gain(self, labels, target_classes):
        &#34;&#34;&#34;
        Finds the split on the given labels which maximises information gain
        
        Parameters
        ----------
        labels : array like of PressureStates or FlowStates
            An array of labels (enumerated flow/pressure states)
        target_classes : array like of PressureStates or FlowStates
            An array of labels (enumerated flow/pressure states) to use to calculate information gain
        
        Returns
        -------
        (int, array like of PressureStates or FlowStates, array like of PressureStates or FlowStates)
            Returns the index of the split, the states up to index, states from index to the end
        &#34;&#34;&#34;
        some_exists = False
        for target_class in target_classes:
            if target_class in labels:
                some_exists = True
                break
        if not some_exists:
            return (0, np.array([]), labels)
        if len(labels) == 0:
            return (0, np.array([]), labels)
        elif len(labels) == 1:
            for target_class in target_classes:
                if target_class in labels:
                    return(1, labels, np.array([]))
            return (0, np.array([]), labels)
        # Find p
        xlen = len(labels)
        forward = np.arange(1,xlen)
        backward = np.arange(xlen-1,0,step=-1)
        p = 0
        p2 = 0
        for target_class in target_classes:
            p += (labels == target_class).cumsum()[:-1]
        p2 = (p[-1] - np.copy(p)) / backward
        p = p / forward
        inf = ((-p * np.log(p + 1E-7)) * forward + (-p2 * np.log(p2 + 1E-7)) * backward) / xlen
        p_prime = 1-p
        p2_prime = 1-p2
        inf += ((-p_prime * np.log(p_prime + 1E-7 )) * forward + (-p2_prime * np.log(p2_prime + 1E-7)) * backward) / xlen
        idx = np.argmin(inf) + 1
        return (idx, labels[:idx], labels[idx:])
       
    def __information_approach(self, p_labels, f_labels, breath):
        &#34;&#34;&#34;
        Tries to identify sub-phases of each breath based on maximising information gain on splitting
        
        Parameters
        ----------
        p_labels : array like of PressureStates enum
            Pressure labels for the record calculated using StateMapper
        f_labels : array like of FlowStates enum
            Flow labels for the record calculated using StateMapper
        breath : BreathVariables object
            BreathVariables object for the breath to calculate sub phases
        
        Returns
        -------
        None
        &#34;&#34;&#34;
        p_labels = p_labels[breath.breath_start:breath.breath_end]
        f_labels = f_labels[breath.breath_start:breath.breath_end]
        labels = f_labels
        # Inspiration initiation at breath start by segmentation definition
        breath.inspiration_initiation_start = breath.breath_start
        # Find Peak inspiratory flow start by finding end of split
        breath.peak_inspiratory_flow_start, _, labels = self.__maximise_information_gain(labels, [fs.inspiration_initiation])
        breath.peak_inspiratory_flow_start += breath.breath_start
        # Find Inspiration termination start by finding end of split
        breath.inspiration_termination_start, _, labels = self.__maximise_information_gain(labels, [fs.peak_inspiratory_flow])
        breath.inspiration_termination_start += breath.peak_inspiratory_flow_start
        # Find Inspiratory Hold start by finding end of split
        breath.inspiratory_hold_start, _, labels = self.__maximise_information_gain(labels, [fs.inspiration_termination])
        breath.inspiratory_hold_start += breath.inspiration_termination_start
        # Find Peak expiratory flow start by finding end of split
        breath.peak_expiratory_flow_start, _, labels = self.__maximise_information_gain(labels, [fs.expiration_initiation])
        breath.peak_expiratory_flow_start += breath.inspiratory_hold_start
        # Find Expiratory hold start by finding end of split
        no_flow, _, labels = self.__maximise_information_gain(labels, [fs.no_flow])
        if no_flow == 0:
            breath.expiratory_hold_start = breath.breath_end
        else:
            breath.expiratory_hold_start = breath.peak_expiratory_flow_start + no_flow        
        # Find Expiration Termination Start by finding end of split
        templabels = f_labels[breath.peak_expiratory_flow_start - breath.breath_start : breath.expiratory_hold_start - breath.breath_start]
        breath.expiration_termination_start, _, labels = self.__maximise_information_gain(templabels, [fs.peak_expiratory_flow])
        breath.expiration_termination_start += breath.peak_expiratory_flow_start
        # Find expiration initiation start by finding end of split
        templabels = f_labels[breath.inspiratory_hold_start - breath.breath_start : breath.peak_expiratory_flow_start - breath.breath_start]
        breath.expiration_initiation_start, _, labels = self.__maximise_information_gain(templabels, [fs.no_flow])
        breath.expiration_initiation_start += breath.inspiratory_hold_start
        
        labels = p_labels
        # Find pip start by finding end of split
        breath.pip_start, _, labels = self.__maximise_information_gain(labels, [ps.pressure_rise])
        breath.pip_start += breath.breath_start
        
        # Find pressure drop start by finding end of split
        breath.pressure_drop_start, _, labels = self.__maximise_information_gain(labels, [ps.pip])
        breath.pressure_drop_start += breath.pip_start
        
        # Find peep start by finding start of split
        breath.peep_start, _, labels = self.__maximise_information_gain(labels, [ps.pressure_drop])
        breath.peep_start += breath.pressure_drop_start
        
        # Find pressure rise start by finding start of split
        breath.pressure_rise_start, _, labels = self.__maximise_information_gain(p_labels[:breath.pip_start - breath.breath_start], [ps.peep])
        breath.pressure_rise_start += breath.breath_start
    
    def __calculate_features(self, breath, pressures, flows):
        &#34;&#34;&#34;
        Calculates the values relevant for physiology like tidal volumes and respiratory phase lengths
        
        Parameters
        ----------
        breath : BreathVariables object
            The breath for which to calculate the physiological values
        pressures : array like of real
            Pressure data points
        flows : array like of real
            Flow data points
        
        Returns
        -------
        None
        &#34;&#34;&#34;
        p = np.array(pressures[breath.breath_start:breath.breath_end])
        f = np.array(flows[breath.breath_start:breath.breath_end])

        # Pressure phases
        breath.pressure_rise_length = breath.pip_start - breath.pressure_rise_start
        breath.pip_length = breath.pressure_drop_start - breath.pip_start
        breath.pressure_drop_length = breath.peep_start - breath.pressure_drop_start
        breath.peep_length = breath.breath_end - breath.peep_start
        
        # Flow phases
        breath.inspiration_initiation_length = breath.peak_inspiratory_flow_start - breath.inspiration_initiation_start
        breath.peak_inspiratory_flow_length = breath.inspiration_termination_start - breath.peak_inspiratory_flow_start
        breath.inspiration_termination_length = breath.inspiratory_hold_start - breath.inspiration_termination_start
        breath.inspiratory_hold_length = breath.expiration_initiation_start - breath.inspiratory_hold_start
        breath.expiration_initiation_length = breath.peak_expiratory_flow_start - breath.expiration_initiation_start
        breath.peak_expiratory_flow_length = breath.expiration_termination_start - breath.peak_expiratory_flow_start
        breath.expiration_termination_length = breath.expiratory_hold_start - breath.expiration_termination_start
        breath.expiratory_hold_length = breath.breath_end - breath.expiratory_hold_start
        breath.lung_inflation_length = breath.inspiratory_hold_start - breath.inspiration_initiation_start
        breath.total_inspiratory_length = breath.expiration_initiation_start - breath.inspiration_initiation_start
        breath.lung_deflation_length = breath.expiratory_hold_start - breath.expiration_initiation_start
        breath.total_expiratory_length = breath.breath_end - breath.expiration_initiation_start
        breath.pip_to_no_flow_length = breath.inspiratory_hold_start - breath.pip_start
        breath.peep_to_no_flow_length = breath.expiratory_hold_start - breath.peep_start
        
        # Volumes
        breath.inspiratory_volume = f[f &gt; 0].sum()
        breath.expiratory_volume = np.abs(f[f &lt; 0].sum())
        breath.max_inspiratory_flow = f.max()
        breath.max_expiratory_flow = f.min()
        
        # Pressures
        breath.max_pressure = p.max()
        breath.min_pressure = p.min()
        
        # Correlation
        breath.pressure_flow_correlation = np.corrcoef(p,f)[0,1]
    
    def __post_process(self, p_labels, f_labels, pressures, flows):
        &#34;&#34;&#34; 
        Performs merging of adjacent breaths dependent on whether inspiration and expiration volumes match
        
        Parameters
        ----------
        p_labels : array like of PressureStates enum
            Pressure labels for the record calculated using StateMapper
        f_labels : array like of FlowStates enum
            Flow labels for the record calculated using StateMapper
        pressures : array like of real
            Pressure data points
        flows : array like of real
            Flow data points
       
        Returns
        -------
        None
        &#34;&#34;&#34;
        merged_breaths = [self.breaths[0]]
        begin_merge = False
        insp_sum = 0
        exp_sum = 0
        error_start = 0
        for i in atpbar(range(1,len(self.breaths)), name=&#34;Post-processing&#34;):
            if not begin_merge:
                breath_leak_perc = (self.breaths[i].inspiratory_volume - self.breaths[i].expiratory_volume) / self.breaths[i].inspiratory_volume
                if abs(breath_leak_perc) &gt; self.leak_perc_thresh:
                    if breath_leak_perc &lt; 0 and self.breaths[i-1].expiratory_hold_length &lt;= self.exp_hold_len:
                        error_start = i - 1
                        merged_breaths.pop()
                        begin_merge = True
                        insp_sum += self.breaths[i-1].inspiratory_volume + self.breaths[i].inspiratory_volume
                        exp_sum += self.breaths[i-1].expiratory_volume + self.breaths[i].expiratory_volume
                    elif breath_leak_perc &gt; 0 and self.breaths[i-1].expiratory_hold_length &lt;= self.exp_hold_len:
                        begin_merge = True
                        error_start = i
                        insp_sum += self.breaths[i].inspiratory_volume
                        exp_sum += self.breaths[i].expiratory_volume
                    else:
                        merged_breaths += [self.breaths[i]]
                else:
                    merged_breaths += [self.breaths[i]]
            else:
                if ((abs(insp_sum - exp_sum)/insp_sum &lt; self.leak_perc_thresh or self.breaths[i-1].expiratory_hold_length &gt; self.exp_hold_len) and error_start != i-1) or (self.breaths[i].pressure_flow_correlation &gt; 0.2 and not self.permit_double_cycling):
                    # Begin to merge breaths
                    begin_merge = False
                    insp_sum = 0
                    exp_sum = 0
                    merged_breath = BreathVariables()
                    merged_breath.breath_start = self.breaths[error_start].breath_start
                    merged_breath.breath_end = self.breaths[i-1].breath_end
                    self.__information_approach(p_labels, f_labels, merged_breath)
                    self.__calculate_features(merged_breath, pressures, flows)
                    merged_breaths += [merged_breath]
                    # Check if current breath needs to be merged
                    breath_leak_perc = (self.breaths[i].inspiratory_volume - self.breaths[i].expiratory_volume) / self.breaths[i].inspiratory_volume
                    if abs(breath_leak_perc) &gt; self.leak_perc_thresh:
                        if breath_leak_perc &lt; 0 and self.breaths[i].expiratory_hold_length &lt;= self.exp_hold_len:
                            merged_breaths.pop()
                            begin_merge = True
                            insp_sum += self.breaths[i-1].inspiratory_volume + self.breaths[i].inspiratory_volume
                            exp_sum += self.breaths[i-1].expiratory_volume + self.breaths[i].expiratory_volume
                        elif breath_leak_perc &gt; 0 and self.breaths[i].expiratory_hold_length &lt;= self.exp_hold_len:
                            begin_merge = True
                            error_start = i
                            insp_sum += self.breaths[i].inspiratory_volume
                            exp_sum += self.breaths[i].expiratory_volume
                        else:
                            merged_breaths += [self.breaths[i]]
                    else:
                        merged_breaths += [self.breaths[i]]
                else:
                    insp_sum += self.breaths[i].inspiratory_volume
                    exp_sum += self.breaths[i].expiratory_volume
        
        self.breaths = merged_breaths
        for i in atpbar(range(len(self.breaths)), name=&#34;Re-numbering breaths&#34;):
            self.breaths[i].breath_number = i+1</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ventiliser.PhaseLabeller.PhaseLabeller.configure"><code class="name flex">
<span>def <span class="ident">configure</span></span>(<span>self, freq=100, hold_length=0.5, leak_perc_thresh=0.66, exp_hold_len=0.05, permit_double_cycling=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the constants for segmentation and post-processing</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>freq</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Sampling rate of the input data. Defaults to 100</dd>
<dt><strong><code>hold_length</code></strong> :&ensp;<code>real</code>, optional</dt>
<dd>Threshold in seconds for the amount of time a breath can be in a no flow state before considered termintated. Defaults to 0.5s</dd>
<dt><strong><code>leak_perc_thresh</code></strong> :&ensp;<code>real</code>, optional</dt>
<dd>The proportion of leak permitted before breath is conidered physiologically implausible and to be flagged for merging in post processing. Defaults to 66%</dd>
<dt><strong><code>exp_hold_len</code></strong> :&ensp;<code>real</code>, optional</dt>
<dd>The time in seconds of the expiratory hold that must occur between breaths to deflag for merging in post-processing. Defaults to 0.05s</dd>
<dt><strong><code>permit_double_cycling</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>Decide whether to merge double cycles in post-processing based on exp_hold_len. Defaults to false.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configure(self, freq=100, hold_length=0.5, leak_perc_thresh=0.66, exp_hold_len=0.05, permit_double_cycling = False):
    &#34;&#34;&#34; 
    Sets the constants for segmentation and post-processing
    
    Parameters
    ----------
    freq : int, optional
        Sampling rate of the input data. Defaults to 100
    hold_length : real, optional
        Threshold in seconds for the amount of time a breath can be in a no flow state before considered termintated. Defaults to 0.5s
    leak_perc_thresh : real, optional
        The proportion of leak permitted before breath is conidered physiologically implausible and to be flagged for merging in post processing. Defaults to 66%
    exp_hold_len : real, optional
        The time in seconds of the expiratory hold that must occur between breaths to deflag for merging in post-processing. Defaults to 0.05s
    permit_double_cycling : boolean, optional
        Decide whether to merge double cycles in post-processing based on exp_hold_len. Defaults to false.
        
    Returns
    -------
    None
    &#34;&#34;&#34;
    self.breaths = []
    self.freq = freq
    self.max_hold = math.ceil(freq * hold_length)
    self.leak_perc_thresh = leak_perc_thresh
    self.exp_hold_len = math.ceil(freq * exp_hold_len)
    self.permit_double_cycling = permit_double_cycling</code></pre>
</details>
</dd>
<dt id="ventiliser.PhaseLabeller.PhaseLabeller.get_breath_annotations"><code class="name flex">
<span>def <span class="ident">get_breath_annotations</span></span>(<span>self, N, p_states=[&lt;PressureStates.peep: 0&gt;, &lt;PressureStates.pressure_rise: 1&gt;, &lt;PressureStates.pip: 2&gt;, &lt;PressureStates.pressure_drop: 3&gt;], f_states=[&lt;FlowStates.no_flow: 0&gt;, &lt;FlowStates.inspiration_initiation: 1&gt;, &lt;FlowStates.peak_inspiratory_flow: 2&gt;, &lt;FlowStates.inspiration_termination: 3&gt;, &lt;FlowStates.expiration_initiation: 4&gt;, &lt;FlowStates.peak_expiratory_flow: 5&gt;, &lt;FlowStates.expiration_termination: 6&gt;])</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a Nx3 dataframe containing key points of breaths mapped to indices to be used with GUI annotator for viewing</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code></dt>
<dd>Length of the sample that was analyzed (in terms of data points)</dd>
<dt><strong><code>p_states</code></strong> :&ensp;<code>array like</code> of <code>PressureStates</code>, optional</dt>
<dd>The pressure states from each breath that you would like mapped. Defaults to all enums in PressureStates.</dd>
<dt><strong><code>f_states</code></strong> :&ensp;<code>array like</code> of <code>FlowStates</code>, optional</dt>
<dd>The flow states from each breath that you woudld like mapped. Defaults to all enums in FlowStates</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Pandas Dataframe</code></dt>
<dd>Dataframe containing keypoints at each index of the data on which the analysis was performed</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_breath_annotations(self, N, p_states=list(ps), f_states=list(fs)):
    &#34;&#34;&#34; 
    Returns a Nx3 dataframe containing key points of breaths mapped to indices to be used with GUI annotator for viewing
    
    Parameters
    ----------
    N : int
        Length of the sample that was analyzed (in terms of data points)
    p_states : array like of PressureStates, optional
        The pressure states from each breath that you would like mapped. Defaults to all enums in PressureStates.
    f_states : array like of FlowStates, optional
        The flow states from each breath that you woudld like mapped. Defaults to all enums in FlowStates
    
    Returns
    -------
    Pandas Dataframe
        Dataframe containing keypoints at each index of the data on which the analysis was performed
    &#34;&#34;&#34;
    output = np.full((N,3), -1)
    output[:,0] = np.arange(N)
    breaths = self.get_breaths_raw()
    for p in p_states:
        if p == ps.pressure_rise:
            output[breaths[&#34;pressure_rise_start&#34;]-1,1] = ps.pressure_rise.value
        elif p == ps.pip:
            output[breaths[&#34;pip_start&#34;]-1,1] = ps.pip.value
        elif p == ps.pressure_drop:
            output[breaths[&#34;pressure_drop_start&#34;]-1,1] = ps.pressure_drop.value
        elif p == ps.peep:
            output[breaths[&#34;peep_start&#34;]-1,1] = ps.peep.value
    for f in f_states:
        if f == fs.inspiration_initiation:
            output[breaths[&#34;inspiration_initiation_start&#34;]-1,2] = fs.inspiration_initiation.value
        elif f == fs.peak_inspiratory_flow:
            output[breaths[&#34;peak_inspiratory_flow_start&#34;]-1,2] = fs.peak_inspiratory_flow.value
        elif f == fs.inspiration_termination:
            output[breaths[&#34;inspiration_termination_start&#34;]-1,2] = fs.inspiration_termination.value
        elif f == fs.no_flow:
            output[breaths[&#34;inspiratory_hold_start&#34;]-1,2] = fs.no_flow.value
            output[breaths[&#34;expiratory_hold_start&#34;]-1,2] = fs.no_flow.value
        elif f == fs.expiration_initiation:
            output[breaths[&#34;expiration_initiation_start&#34;]-1,2] = fs.expiration_initiation.value
        elif f == fs.peak_expiratory_flow:
            output[breaths[&#34;peak_expiratory_flow_start&#34;]-1,2] = fs.peak_expiratory_flow.value
        elif f == fs.expiration_termination:
            output[breaths[&#34;expiration_termination_start&#34;]-1,2] = fs.expiration_termination.value
    output = output[output[:,1:].sum(axis=1) != -2,:]
    output = pd.DataFrame(output)
    output.columns = [&#34;index&#34;,&#34;pressure_annotations&#34;,&#34;flow_annotations&#34;]
    return output</code></pre>
</details>
</dd>
<dt id="ventiliser.PhaseLabeller.PhaseLabeller.get_breaths"><code class="name flex">
<span>def <span class="ident">get_breaths</span></span>(<span>self, length_units='ms')</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the segmented breaths and calculated features as a pandas dataframe. See BreathVariables for list of variables returned</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>length_units</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Unit to use for length calculations, accepts 'ms' and 's' for milliseconds and seconds respectively. Defaults to ms</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Pandas Dataframe</code></dt>
<dd>Table of segmented breaths and charactersitics for each breath with lengths scaled according to given unit</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_breaths(self, length_units=&#34;ms&#34;):
    &#34;&#34;&#34;
    Returns the segmented breaths and calculated features as a pandas dataframe. See BreathVariables for list of variables returned
    
    Parameters
    ----------
    length_units : string, optional
        Unit to use for length calculations, accepts &#39;ms&#39; and &#39;s&#39; for milliseconds and seconds respectively. Defaults to ms
    
    Returns
    --------
    Pandas Dataframe
        Table of segmented breaths and charactersitics for each breath with lengths scaled according to given unit
    &#34;&#34;&#34;
    df = pd.DataFrame([vars(x) for x in self.breaths])
    if length_units == &#34;ms&#34;:
        df[list(filter(lambda x : &#34;length&#34; in x, df.columns))] *= 1000 / self.freq
    elif length_units == &#34;s&#34;:
        df[list(filter(lambda x : &#34;length&#34; in x, df.columns))] *= 1 / self.freq
    return df[[&#34;breath_number&#34;, &#34;breath_start&#34;, &#34;breath_end&#34;, &#34;inspiration_initiation_start&#34;, &#34;peak_inspiratory_flow_start&#34;,
              &#34;inspiration_termination_start&#34;, &#34;inspiratory_hold_start&#34;, &#34;expiration_initiation_start&#34;,     &#34;peak_expiratory_flow_start&#34;,
              &#34;expiration_termination_start&#34;, &#34;expiratory_hold_start&#34;, &#34;pressure_rise_start&#34;, &#34;pip_start&#34;, &#34;pressure_drop_start&#34;,
              &#34;peep_start&#34;, &#34;inspiration_initiation_length&#34;, &#34;peak_inspiratory_flow_length&#34;,
              &#34;inspiration_termination_length&#34;, &#34;inspiratory_hold_length&#34;, &#34;expiration_initiation_length&#34;, &#34;peak_expiratory_flow_length&#34;,
              &#34;expiration_termination_length&#34;, &#34;expiratory_hold_length&#34;, &#34;pressure_rise_length&#34;, &#34;pip_length&#34;, &#34;pressure_drop_length&#34;,
              &#34;peep_length&#34;, &#34;pip_to_no_flow_length&#34;, &#34;peep_to_no_flow_length&#34;, &#34;lung_inflation_length&#34;, &#34;total_inspiratory_length&#34;,
              &#34;lung_deflation_length&#34;, &#34;total_expiratory_length&#34;, &#34;inspiratory_volume&#34;, &#34;expiratory_volume&#34;, &#34;max_inspiratory_flow&#34;,
              &#34;max_expiratory_flow&#34;, &#34;max_pressure&#34;, &#34;min_pressure&#34;, &#34;pressure_flow_correlation&#34;]]</code></pre>
</details>
</dd>
<dt id="ventiliser.PhaseLabeller.PhaseLabeller.get_breaths_raw"><code class="name flex">
<span>def <span class="ident">get_breaths_raw</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the segmented breaths and calculated features as a pandas dataframe. See BreathVariables for list of variables returned</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Pandas Dataframe</code></dt>
<dd>Table of segmented breaths and charactersitics for each breath</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_breaths_raw(self):
    &#34;&#34;&#34;
    Returns the segmented breaths and calculated features as a pandas dataframe. See BreathVariables for list of variables returned
    
    Returns
    --------
    Pandas Dataframe
        Table of segmented breaths and charactersitics for each breath
    &#34;&#34;&#34;
    return pd.DataFrame([vars(x) for x in self.breaths])</code></pre>
</details>
</dd>
<dt id="ventiliser.PhaseLabeller.PhaseLabeller.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self, p_labels, f_labels, pressures, flows, post_processing=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Given the pressure and flow data points and labels, segments the data into breaths, identifies respiratory sub-phases, and calculates some physiological values</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_labels</code></strong> :&ensp;<code>array like</code> of <code>PressureStates enum</code></dt>
<dd>The PressureStates labels generated from StateMapper</dd>
<dt><strong><code>f_labels</code></strong> :&ensp;<code>array like</code> of <code>FlowStates enum</code></dt>
<dd>The FlowStates labels generated from StateMapper</dd>
<dt><strong><code>pressures</code></strong> :&ensp;<code>array like</code> of <code>real</code></dt>
<dd>Pressure data points</dd>
<dt><strong><code>flows</code></strong> :&ensp;<code>array like</code> of <code>real</code></dt>
<dd>Flow data points</dd>
<dt><strong><code>post_processing</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>Flag for deciding whether to run post processing or not. Defaults to True</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self, p_labels, f_labels, pressures, flows, post_processing=True):
    &#34;&#34;&#34;
    Given the pressure and flow data points and labels, segments the data into breaths, identifies respiratory sub-phases, and calculates some physiological values
    
    Parameters
    ----------
    p_labels : array like of PressureStates enum
        The PressureStates labels generated from StateMapper
    f_labels : array like of FlowStates enum
        The FlowStates labels generated from StateMapper
    pressures : array like of real
        Pressure data points
    flows : array like of real
        Flow data points
    post_processing : boolean, optional
        Flag for deciding whether to run post processing or not. Defaults to True
        
    Returns
    -------
    None
    &#34;&#34;&#34;
    if type(pressures) is not np.array:
        pressures = np.array(pressures)
    if type(flows) is not np.array:
        flows = np.array(flows)
    print(&#34;Segmenting into breaths&#34;)
    self.breaths += [BreathVariables()]
    self.breaths[-1].breath_end = 0
    while(self.breaths[-1].breath_end != len(f_labels)):
        self.breaths += [self.__get_next_breath(f_labels, self.breaths[-1].breath_end)]
    # First and last breaths are usually inaccurate
    if len(self.breaths) &gt; 1:
        self.breaths = self.breaths[1:]
        print(str(len(self.breaths)) + &#34; breaths identified&#34;)
        for i in atpbar(range(len(self.breaths)), name=&#34;Processing breaths&#34;):
            self.breaths[i].breath_number = i+1
            self.__information_approach(p_labels, f_labels, self.breaths[i])
            self.__calculate_features(self.breaths[i], pressures, flows)
        if post_processing:
            self.__post_process(p_labels, f_labels, pressures, flows)
    else:
        self.breaths = []
        print(&#34;Warning: No breaths identified&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ventiliser" href="index.html">ventiliser</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ventiliser.PhaseLabeller.PhaseLabeller" href="#ventiliser.PhaseLabeller.PhaseLabeller">PhaseLabeller</a></code></h4>
<ul class="">
<li><code><a title="ventiliser.PhaseLabeller.PhaseLabeller.configure" href="#ventiliser.PhaseLabeller.PhaseLabeller.configure">configure</a></code></li>
<li><code><a title="ventiliser.PhaseLabeller.PhaseLabeller.get_breath_annotations" href="#ventiliser.PhaseLabeller.PhaseLabeller.get_breath_annotations">get_breath_annotations</a></code></li>
<li><code><a title="ventiliser.PhaseLabeller.PhaseLabeller.get_breaths" href="#ventiliser.PhaseLabeller.PhaseLabeller.get_breaths">get_breaths</a></code></li>
<li><code><a title="ventiliser.PhaseLabeller.PhaseLabeller.get_breaths_raw" href="#ventiliser.PhaseLabeller.PhaseLabeller.get_breaths_raw">get_breaths_raw</a></code></li>
<li><code><a title="ventiliser.PhaseLabeller.PhaseLabeller.process" href="#ventiliser.PhaseLabeller.PhaseLabeller.process">process</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>